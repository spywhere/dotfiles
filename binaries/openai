#!/bin/bash

debug=0
timeout=30

cmd_name="$(basename "$0")"
temp=""
token=""
model="gpt-3.5-turbo"
# context=0

if test -z "$OPENAI_API_BASE"; then
  OPENAI_API_BASE="https://api.openai.com/v1"
fi

fallback_default() {
  if test -z "$1"; then
    printf 'OpenAI spec'
  else
    printf '%s' "$1"
  fi
}

usage() {
  echo "USAGE"
  echo "  $cmd_name [flags] [--] <prompt>..."
  echo "  cat <filename> | $cmd_name [flags]"
  echo
  echo "ENVIRONMENT VARIABLES"
  echo "  OPENAI_API_BASE                Host for OpenAI API (default to $(fallback_default "$OPENAI_API_BASE"))"
  echo "  OPENAI_API_KEY                 API key for the given OpenAI base"
  echo
  echo "FLAGS"
  echo "  -h, --help                 Show this message"
  echo "  -T, --temperature=<temp>   Sampling temperature, higher is more random (default to $(fallback_default "$temp"))"
  echo "  -t, --max-tokens=<number>  Maximum number of tokens to generate in the completion (default to $(fallback_default "$token"))"
  echo "  -m, --model=<name>         ID of the model to use (default to $(fallback_default "$model"))"
  # echo "  -c, --context              Use chat context (default to false)"
  echo "  --timeout=<number>         Maximum number of seconds before request timed out (default to 10)"
  echo "  --models                   List all available models"
  echo
  echo "PROMPT HELPER"
  echo "  --cmd, --command           Produce only shell command output"
  echo "  --code                     Produce only one-liner code"
  echo "  --url                      Produce only URL for the given query"
}

prompt_prefix() {
  local prompt
  case "$1" in
    copilot)
      prompt='a structured and complete explanations of shell commands. We follow the commands piece-by-piece in bullet-point form, with multiple statements being separate bullets. Sub-commands form sub-bullets. All flags are explained as sub-bullets.'
      ;;
    command)
      prompt='a one-liner posix shell command with no prompt or explanation.'
      ;;
    code)
      prompt='a one-liner code with no prompt or explanation.'
      ;;
    url)
      prompt='an URL regarding on the topic given.'
      ;;
  esac

  printf 'Given the user request, only produce %s' "$prompt"
}

copilot_examples() {
  local prompts="$*"
  local result

  local command='find -name "*.ts" | grep -v node_modules'
  prompts="$(additem "$prompts" "$(printf '{"role":"user","content":%s}' "$(tojson "$command")")")"
  # shellcheck disable=SC2016
  result="$(printf -- '--- Command ---\n\n%s\n\n--- Explanation ---\n\n- %s\n  - %s\n- %s\n  - %s' "$command" '`find` is used to list files.' '`-name "*.ts"` stipulates that we search for files ending in `.ts`.' '`| grep` means we pass that list of files to `grep` which filters the list.' '`-v node_modules` means we exclude all files containing node_modules in its path.')"
  prompts="$(additem "$prompts" "$(printf '{"role":"assistant","content":%s}' "$(tojson "$result")")")"

  # shellcheck disable=SC2016
  command="$(printf '%s\n  %s\n  %s\n%s' 'for file in $(find -name "*.py"); do' 'echo "$file";' 'wc -l $file;' 'done')"
  prompts="$(additem "$prompts" "$(printf '{"role":"user","content":%s}' "$(tojson "$command")")")"
  # shellcheck disable=SC2016
  result="$(printf -- '--- Command ---\n\n%s\n\n--- Explanation ---\n\n- %s\n  - %s\n    - %s\n- %s\n  - %s\n  - %s\n    - %s' "$command" 'The for loop iterates over a list of items and executes its body for each, using the loop variable `$file`.' 'The list of items is the output of a sub-call to `find` which is used to list files.' '`-name "*.py"` stipulates that we search for files ending in `.py`.' 'The loop body executes two commands for each file:' '`echo "$file"` will print the name of the current file to the terminal.' '`wc` is used to count the number of lines in the current file.' '`-l` specifies that we only want the line count, not the word or character count.')"
  prompts="$(additem "$prompts" "$(printf '{"role":"assistant","content":%s}' "$(tojson "$result")")")"

  printf '%s' "$prompts"
}

additional_prompts() {
  case "$1" in
    copilot)
      copilot_examples "$2"
      ;;
    *)
      printf '%s' "$2"
  esac
}

handle_gpt_response() {
  local response="$1"
  local errmsg
  errmsg="$(printf '%s' "$response" | jq -er '.error.message')"
  if test "$?" -eq 0; then
    printf 'ERROR: [%s] %s\n' "$(printf '%s' "$response" | jq -r '.error.type')" "$errmsg" >&2
    return 1
  fi
  return 0
}

openai() {
  local path="$1"
  local body="$2"
  local filter="$3"
  local method="POST"
  if test -z "$3"; then
    body=""
    filter="$2"
    method="GET"
  elif test "$debug" -ge 1; then
    printf 'Req[%s]: %s\n' "$path" "$body" >&2
  fi
  if test "$debug" -eq 2; then
    return 4
  fi
  local response
  response="$(curl -m "$timeout" -X "$method" -d "$body" -sSL "$OPENAI_API_BASE/$path" -H 'Content-Type: application/json' -H "Authorization: Bearer $OPENAI_API_KEY" 2>/dev/null)"
  if test $? -ne 0; then
    return 1
  fi

  if test "$debug" -ge 1; then
    printf 'Res[%s]: %s\n' "$path" "$response" >&2
  fi

  printf '%s' "$response" | jq '.' >/dev/null 2>&1
  if test $? -ne 0; then
    return 2
  fi

  if ! handle_gpt_response "$response"; then
    return 3
  fi

  printf '%s' "$response" | jq -r "$filter"
}

handle_status() {
  local status="$1"
  case "$status" in
    0)
      ;;
    1)
      echo "ERROR: Request timed out"
      ;;
    2)
      echo "ERROR: Bad response"
      ;;
    3|4)
      ;;
    *)
      echo "ERROR: Request failed"
      ;;
  esac
  return "$status"
}

tojson() {
  printf '%s' "$*" | jq -sRr 'tojson'
}

setitem() {
  printf '{"o":%s,"k":%s,"v":%s}' "$1" "$(tojson "$2")" "$3" | jq -rc '.o[.k] = .v | .o'
}

additem() {
  printf '{"o":%s,"i":%s}' "$1" "$2" | jq -rc '.o + [.i]'
}

models() {
  echo "Available models:"
  openai models '.data[] | "  - \(.id)\n      by: \(.owned_by)"'
  if ! handle_status "$?"; then
    exit 1
  fi
}

main() {
  local use_stdin=1
  if tty -s >/dev/null 2>&1; then
    use_stdin=0
  fi
  local kind=""
  while test "$1" != ""; do
    local param
    param="$(printf "%s" "$1" | sed 's/=.*//g')"
    local value
    value="$(printf "%s" "$1" | sed 's/^[^=]*=//g')"
    local equal_sign
    equal_sign="$(printf "%s" "$1" | sed 's/[^=]//g')"
    case "$param" in
      -h | --help)
        usage
        return
        ;;
      --models)
        models
        return
        ;;
      --timeout)
        if test -z "$equal_sign"; then
          echo "ERROR: a number of seconds is required (perhaps missing an equal sign?)"
          return 1
        fi
        timeout="$value"
        ;;
      -T | --temperature)
        if test -z "$equal_sign"; then
          echo "ERROR: a temperature is required (perhaps missing an equal sign?)"
          return 1
        fi
        temp="$value"
        ;;
      -t | --max-tokens)
        if test -z "$equal_sign"; then
          echo "ERROR: a number of tokens is required (perhaps missing an equal sign?)"
          return 1
        fi
        token="$value"
        ;;
      -m | --model)
        if test -z "$equal_sign"; then
          echo "ERROR: a model ID is required (perhaps missing an equal sign?)"
          return 1
        fi
        model="$value"
        ;;
      # -c | --context)
      #   context=1
      #   ;;
      --copilot)
        kind="copilot"
        ;;
      --cmd | --command)
        kind="command"
        ;;
      --code)
        kind="code"
        ;;
      --url)
        kind="url"
        ;;
      --debug)
        debug=1
        ;;
      --debug-dry)
        debug=2
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo "ERROR: unknown flag \"$1\""
        return 1
        ;;
      *)
        break
        ;;
    esac

    shift
  done

  if test -z "$OPENAI_API_KEY"; then
    echo "ERROR: OPENAI_API_KEY is required"
    return 1
  fi

  local prompt=""
  if test "$use_stdin" -eq 1; then
    prompt="$(cat -)"
  else
    prompt="$*"
  fi
  if test -z "$prompt"; then
    echo "No prompt given"
    echo "Use --help for usage"
    return
  fi

  local body="{}"

  if test -n "$model"; then
    body="$(setitem "$body" "model" "$(tojson "$model")")"
  fi
  if test -n "$token"; then
    body="$(setitem "$body" "max_tokens" "$token")"
  fi
  if test -n "$temp"; then
    body="$(setitem "$body" "temperature" "$temp")"
  fi

  local prompts="[]"
  if test -n "$kind"; then
    prompts="$(additem "$prompts" "$(printf '{"role":"system","content":%s}' "$(tojson "$(prompt_prefix "$kind")")")")"
    prompts="$(additional_prompts "$kind" "$prompts")"
  fi

  prompts="$(additem "$prompts" "$(printf '{"role":"user","content":%s}' "$(tojson "$prompt")")")"
  body="$(setitem "$body" "messages" "$prompts")"
  response="$(openai chat/completions "$body" '.')"
  if ! handle_status "$?"; then
    return 1
  fi
  printf '%s\n' "$response" | jq -r '.choices[] | .message.content'
}

main "$@"
