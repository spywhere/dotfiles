#!/bin/bash

debug=0
timeout=10

usage() {
  echo "USAGE"
  echo "  gpt [flags] [--] <prompt>..."
  echo "  cat <filename> | gpt [flags]"
  echo
  echo "REQUIRES"
  echo "  OPENAI_KEY                 API Key for OpenAI"
  echo
  echo "FLAGS"
  echo "  -h, --help                 Show this message"
  echo "  -T, --temperature=<temp>   Sampling temperature, higher is more random (default 0.7)"
  echo "  -t, --max-tokens=<number>  Maximum number of tokens to generate in the completion (default to 1024)"
  echo "  -m, --model=<name>         ID of the model to use (default to gpt2)"
  echo "  -s, --size=<number>        Image size to be generated (default is 512x512)"
  echo "  -c, --context              Use chat context (default is false)"
  echo "  --timeout=<number>         Maximum number of seconds before request timed out (default is 10)"
  echo "  --models                   List all available models"
  echo
  echo "PROMPT HELPER"
  echo "  --cmd, --command           Produce only shell command output"
  echo "  --code                     Produce only one-liner code"
}

prompt_prefix() {
  case "$1" in
    command)
      printf '%s\nPrompt: ' 'Given the prompt, only produce one-liner shell command.'
      ;;
    code)
      printf '%s\nPrompt: ' 'Given the prompt, only produce a one-liner code.'
      ;;
  esac
}

handle_gpt_response() {
  local response="$1"
  local errmsg
  errmsg="$(printf '%s' "$response" | jq -er '.error.message')"
  if test "$?" -eq 0; then
    printf 'ERROR: [%s] %s\n' "$(printf '%s' "$response" | jq -r '.error.type')" "$errmsg" >&2
    return 1
  fi
  return 0
}

gpt() {
  local path="$1"
  local body="$2"
  local filter="$3"
  local method="POST"
  if test -z "$3"; then
    body=""
    filter="$2"
    method="GET"
  elif test "$debug" -eq 1; then
    printf 'Req[%s]: %s\n' "$path" "$body" >&2
  fi
  local response
  response="$(curl -m "$timeout" -X "$method" -d "$body" -sSL "https://api.openai.com/v1/$path" -H 'Content-Type: application/json' -H "Authorization: Bearer $OPENAI_KEY" 2>/dev/null)"
  if test $? -ne 0; then
    return 1
  fi

  if test "$debug" -eq 1; then
    printf 'Res[%s]: %s\n' "$path" "$response" >&2
  fi

  printf '%s' "$response" | jq '.' >/dev/null 2>&1
  if test $? -ne 0; then
    return 2
  fi

  if ! handle_gpt_response "$response"; then
    return 3
  fi

  printf '%s' "$response" | jq -r "$filter"
}

handle_status() {
  local status="$1"
  case "$status" in
    0)
      ;;
    1)
      echo "ERROR: Request timed out"
      ;;
    2)
      echo "ERROR: Bad response"
      ;;
    3)
      ;;
    *)
      echo "ERROR: Request failed"
      ;;
  esac
  return "$status"
}

tojson() {
  printf '%s' "$*" | jq -sRr 'tojson'
}

models() {
  echo "Available models:"
  gpt models '.data[] | "  - \(.id)\n      by: \(.owned_by)"'
  if ! handle_status "$?"; then
    exit 1
  fi
}

main() {
  local use_stdin=1
  if tty -s >/dev/null 2>&1; then
    use_stdin=0
  fi
  local temp="0.7"
  local token="1024"
  local model="text-davinci-003"
  local size="512x512"
  local context=0
  local kind=""
  while test "$1" != ""; do
    local param
    param="$(printf "%s" "$1" | sed 's/=.*//g')"
    local value
    value="$(printf "%s" "$1" | sed 's/^[^=]*=//g')"
    local equal_sign
    equal_sign="$(printf "%s" "$1" | sed 's/[^=]//g')"
    case "$param" in
      -h | --help)
        usage
        return
        ;;
      --models)
        models
        return
        ;;
      --timeout)
        if test -z "$equal_sign"; then
          echo "ERROR: a number of seconds is required (perhaps missing an equal sign?)"
          return 1
        fi
        timeout="$value"
        ;;
      -T | --temperature)
        if test -z "$equal_sign"; then
          echo "ERROR: a temperature is required (perhaps missing an equal sign?)"
          return 1
        fi
        temp="$value"
        ;;
      -t | --max-tokens)
        if test -z "$equal_sign"; then
          echo "ERROR: a number of tokens is required (perhaps missing an equal sign?)"
          return 1
        fi
        token="$value"
        ;;
      -m | --model)
        if test -z "$equal_sign"; then
          echo "ERROR: a model ID is required (perhaps missing an equal sign?)"
          return 1
        fi
        model="$value"
        ;;
      -s | --size)
        if test -z "$equal_sign"; then
          echo "ERROR: an image size is required (perhaps missing an equal sign?)"
          return 1
        fi
        size="$value"
        ;;
      -c | --context)
        context=1
        ;;
      --cmd | --command)
        kind="command"
        ;;
      --code)
        kind="code"
        ;;
      --debug)
        debug=1
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo "ERROR: unknown flag \"$1\""
        return 1
        ;;
      *)
        break
        ;;
    esac

    shift
  done

  if test -z "$OPENAI_KEY"; then
    echo "ERROR: OPENAI_KEY is required"
    return 1
  fi

  local prompt=""
  if test "$use_stdin" -eq 1; then
    prompt="$(cat -)"
  else
    prompt="$*"
  fi
  if test -z "$prompt"; then
    echo "No prompt given"
    return
  fi
  if test -n "kind"; then
    prompt="$(prompt_prefix "$kind")$prompt"
  fi
  local body
  body="$(printf '{"model":%s,"prompt":%s,"max_tokens":%s,"temperature":%s}' "$(tojson "$model")" "$(tojson "$prompt")" "$token" "$temp")"
  response="$(gpt completions "$body" '.')"
  if ! handle_status "$?"; then
    return 1
  fi

  printf '%s\n' "$response" | jq -r '.choices[] | .text' | sed '1,2d'
  if test "$debug" -eq 1; then
    local usage
    usage="$(printf '%s' "$response" | jq -r '.usage')"
    printf -- '-- prompt tokens    : %s\n-- completion tokens: %s\n-- total tokens     : %s\n' "$(printf '%s' "$usage" | jq -r '.prompt_tokens')" "$(printf '%s' "$usage" | jq -r '.completion_tokens')" "$(printf '%s' "$usage" | jq -r '.total_tokens')" >&2
  fi
}

main "$@"
