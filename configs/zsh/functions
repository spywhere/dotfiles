#!/bin/bash
flashlight() {
  local color="7"
  local duration="10"

  while test "$1" != ""; do
    case "$1" in
      -c|--color)
        shift
        if test -z "$1"; then
          echo "ERROR: color is required"
          return 1
        fi

        case "$1" in
          red)
            color="1"
            ;;
          green)
            color="2"
            ;;
          yellow)
            color="3"
            ;;
          blue)
            color="4"
            ;;
          pink|purple)
            color="5"
            ;;
          cyan)
            color="6"
            ;;
          white)
            color="7"
            ;;
          black)
            color="8"
            ;;
          *)
            color="$1"
        esac
        ;;
      *)
        break
        ;;
    esac

    shift
  done

  if test $# -gt 0; then
    duration="$1"
  fi

  printf "%s" "$(tput setab "$color")$(tput clear)" && sleep "$duration"
}

keep() {
  if test $# -eq 0; then
    echo -e "No arguments specified. usage:\necho keep /tmp/test.md\ncat /tmp/test.md | keep test.md"
    return 1
  fi
  tmpfile=$(mktemp -t transferXXX);
  if tty -s; then
    basefile=$(basename "$1" | sed -e 's/[^a-zA-Z0-9._-]/-/g')
    curl --progress-bar --upload-file "$1" "https://free.keep.sh/$basefile" >> $tmpfile
  else
    curl --progress-bar --upload-file "-" "https://free.keep.sh/$1" >> $tmpfile
  fi
  cat $tmpfile
  rm -f $tmpfile
}

# Transfer.sh will not be available after October 2020
transfer() {
  if test $# -eq 0; then
    echo -e "No arguments specified. Usage:\necho transfer /tmp/test.md\ncat /tmp/test.md | transfer test.md"
    return 1
  fi
  tmpfile=$(mktemp -t transferXXX);
  if tty -s; then
    basefile=$(basename "$1" | sed -e 's/[^a-zA-Z0-9._-]/-/g')
    curl --progress-bar --upload-file "$1" "https://transfer.sh/$basefile" >> $tmpfile
  else
    curl --progress-bar --upload-file "-" "https://transfer.sh/$1" >> $tmpfile
  fi
  cat $tmpfile
  rm -f $tmpfile
}

map() {
  if test `command -v npx`; then
    npx mapscii
    return
  fi
  docker info >/dev/null 2>&1
  if test $? -eq 0; then
    docker run -it --rm --name map-cli node:lts-alpine npx mapscii
    return
  fi
  if test `command -v telnet`; then
    telnet mapscii.me
  fi
}

rebuild-mosh() {
  local workdir="$(pwd)"
  local clean=""
  local tmpdir="$(mktemp -d)"
  if test "$#" -eq 0; then
    clean="yes"
    git clone --depth 1 https://github.com/mobile-shell/mosh "$tmpdir"
  else
    tmpdir="$1"
  fi
  if test ! -d "$tmpdir"; then
    printf "Directory is not exists: %s\n" "$tmpdir"
    return 1
  fi
  cd "$tmpdir"
  ./autogen.sh
  ./configure
  make
  sudo make install
  if test -n "$clean"; then
    sudo rm -rf "$tmpdir"
  fi

  cd "$workdir"
}

url_to() {
  local url=""
  read url

  local protocol='ssh'
  local separator=':'

  if printf '%s' "$url" | grep -q '://'; then
    protocol="$(printf '%s' "$url" | cut -d':' -f1)"
    # remove protocol
    url="$(printf '%s' "$url" | cut -d'/' -f3-)"
    separator='/'
  fi

  local domain="$(printf '%s' "$url" | cut -d "$separator" -f1)"
  local url_path="$(printf '%s' "$url" | cut -d "$separator" -f2-)"
  local git_path="$(printf '%s' "$url_path" | sed 's/.git$//g')"
  local user=''

  if printf '%s' "$domain" | grep -q '@'; then
    user="$(printf '%s' "$domain" | cut -d'@' -f1)"
    domain="$(printf '%s' "$domain" | cut -d'@' -f2)"
  fi

  local default_output=""
  if test "$protocol" = 'ssh'; then
    default_output='https'
  else
    default_output='ssh'
  fi

  while test -n "$1" || test -n "$default_output"; do
    if test "$1" = "github.com" || test "$1" = "github" || test "$1" = "gh"; then
      printf 'git@%s' "github.com:$git_path.git"
    elif test "$1" = "sr.ht" || test "$1" = "srht"; then
      printf 'git@%s' "git.sr.ht:~$git_path"
    elif test "$1" = "ssh" || test "$default_output" = "ssh"; then
      if test -n "$user"; then
        printf '%s@' "$user"
      fi

      printf '%s:%s' "$domain" "$url_path"
    elif test "$1" = "http" || test "$1" = "https" || test "$default_output" = "https"; then
      if test -n "$1"; then
        printf '%s://' "$1"
      else
        printf '%s://' "$default_output"
      fi
      if test -n "$user"; then
        printf '%s@' "$user"
      fi

      printf '%s/%s' "$domain" "$url_path"
    fi

    printf '\n'

    if test -n "$1"; then
      shift
    fi
    default_output=''
  done
}

_gh_api() {
  local method="$1"
  shift
  local host="$1"
  shift
  if test -z "$host"; then
    gh api -X $method $@ 2>/dev/null
  else
    gh api -X $method --hostname $host $@ 2>/dev/null
  fi
}

search_github() {
  local host=""
  while test -n "$1"; do
    local param="$1"
    case $param in
      -H | --hostname)
        shift
        if test -z "$1"; then
          echo "ERROR: hostname is required"
          return 1
        fi
        host="$1"
        ;;
      *)
        break
        ;;
    esac
    shift
  done

  local query="$@"
  if test -z "$query"; then
    echo "usage: $0 [flag]... <query>"
    echo
    echo "Search GitHub for issues/prs using specified query"
    echo
    echo "flags:"
    echo "  --hostname, -H <hostname>    Set GitHub host (default to github.com)"
    return 1
  fi
  _gh_api GET "$host" /search/issues -f q="$query" -q '.items[]'
}

_is_number() {
  case $@ in
    '' | *[!0-9]*)
      return 1
      ;;
    *)
      return 0
      ;;
  esac
}

_label_operation() {
  local operation="$1"
  shift

  local host=""
  local dry=""
  local labels=""
  # process labels
  while test -n "$1"; do
    local label="$1"
    shift
    if test "$label" = "--dry"; then
      dry="yes"
      continue
    elif test "$label" = "-H" -o "$label" = "--hostname"; then
      if test -z "$1"; then
        echo "ERROR: hostname is required"
        return 1
      fi
      host="$1"
      shift
      continue
    elif test "$label" = "--"; then
      break
    fi
    if test -z "$labels"; then
      labels=$label
    else
      labels=$(printf "%s\0%s" "$labels" "$label")
    fi
  done

  if test -z "$labels"; then
    echo "usage: $0 [flag]... <label name>... -- [issue/pr number]..."
    echo
    echo "flags:"
    echo "  --dry                      Show the action that will be perform"
    echo "  --hostname, H <hostname>   Set GitHub host (default to github.com)"
    echo "  --                         Stop processing labels and start processing issue/pr numbers"
    return 1
  fi

  if test -z "$1"; then
    # process issue numbers from stdin
    while IFS= read -r issue; do
      "$operation" "$dry" "$host" "$issue" "$labels"
    done
    return 0
  fi

  # process issue numbers from arguments
  while test -n "$1"; do
    "$operation" "$dry" "$host" "$1" "$labels"
    shift
  done
}

apply_label() {
  apply_label_to_issue() {
    local dry="$1"
    shift
    local host="$1"
    shift
    local issue="$1"
    shift
    local labels="\"$(echo "$@" | sed 's/\x0/", "/g')\""

    printf "Applying label $labels to issue #$issue..."
    if ! _is_number $issue; then
      printf " fail\nERROR: Issue \"%s\" is not a valid number\n" "$issue"
      return
    fi

    local response=""
    if test -z "$dry"; then
      response=$(printf '{"labels": [%s]}' "$labels" | _gh_api POST "$host" /repos/:owner/:repo/issues/$issue/labels --input -)
    fi
    if test $? -eq 0; then
      printf " done\n"
    else
      printf " fail\n"
      printf "%s\n" "$response"
    fi
  }

  _label_operation apply_label_to_issue $@
}

remove_label() {
  remove_label_from_issue() {
    local dry="$1"
    shift
    local host="$1"
    shift
    local issue="$1"
    shift
    local labels="$@"

    while read -r label; do
      printf "Removing label \"$label\" from issue #$issue..."
      if ! _is_number $issue; then
        printf " fail\nERROR: Issue \"%s\" is not a valid number\n" "$issue"
        continue
      fi

      local response=""
      if test -z "$dry"; then
        response=$(_gh_api DELETE "$host" "/repos/:owner/:repo/issues/$issue/labels/$(printf "%s" "$label" | jq -sRr @uri)")
      fi
      if test $? -eq 0; then
        printf " done\n"
      else
        printf " fail\n"
        printf "%s\n" "$response"
      fi
    done <<< $(echo $labels | xargs -d'\0' -n1)
  }

  _label_operation remove_label_from_issue $@
}

TMATE_SOCKET='/tmp/tmate-pair.sock'
pair() {
  local current_session="$(tmux display-message -p '#S')"
  local session_name="$(whoami)-pair"

  if test -n "$1"; then
    session_name="$1"
  fi

  if tmate -S "$TMATE_SOCKET" has-session -t "tmate-$session_name" >/dev/null 2>&1; then
    echo 'Existing pairing session found, unpairing...'
    unpair
  fi
  if tmux has-session -t "$session_name" >/dev/null 2>&1; then
    echo 'Existing pairing session found, unpairing...'
    unpair "$session_name"
  fi

  local autodestroy="$(tmux show-options -qgv destroy-unattached)"
  if test "$autodestroy" = 'on'; then
    echo 'Turning off auto destroy for unattached sessions...'
    tmux set -g @tmux-pair-auto-destroy on
    tmux set -g destroy-unattached off
  fi

  echo 'Creating a new pairing session...'
  tmux new-session -d -s "$session_name" "unset TMUX && tmate -S '$TMATE_SOCKET' -f '$HOME/.dots/configs/tmate/tmate-pair.conf' new-session -s 'tmate-$session_name' 'unset TMUX && tmux attach-session -t $current_session'"

  echo 'Waiting for connection...'
  while ! tmate -S "$TMATE_SOCKET" wait tmate-ready >/dev/null 2>&1; do
    sleep 1
  done
  tmate -S "$TMATE_SOCKET" send-keys -t "tmate-$session_name" q
  echo "  Web:" "$(tmate -S "$TMATE_SOCKET" display -p '#{tmate_web}')"
  echo "  Web Read-Only:" "$(tmate -S "$TMATE_SOCKET" display -p '#{tmate_web_ro}')"
  echo "  SSH:" "$(tmate -S "$TMATE_SOCKET" display -p '#{tmate_ssh}')"
  echo "  SSH Read-Only:" "$(tmate -S "$TMATE_SOCKET" display -p '#{tmate_ssh_ro}')"
}

unpair() {
  local session_name="$(whoami)-pair"

  if test -n "$1"; then
    session_name="$1"
  fi

  if tmate -S "$TMATE_SOCKET" has-session -t "tmate-$session_name" >/dev/null 2>&1; then
    tmate -S "$TMATE_SOCKET" kill-session -t "tmate-$session_name"
  fi
  if tmux has-session -t "$session_name" >/dev/null 2>&1; then
    tmux kill-session -t "$session_name"
  fi

  local autodestroy="$(tmux show-options -qgv @tmux-pair-auto-destroy)"
  if test "$autodestroy" = 'on'; then
    tmux set -g destroy-unattached on
  fi

  tmux set -gu @tmux-pair-auto-destroy
}
